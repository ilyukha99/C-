//int new_uint = pow(2, uint_size), res = 0;
//for (int it = 0; it != uint_size; ++it) {
//	res += new_uint * binary_decomposition[it];
//	new_uint = new_uint / 2;
//}

//for (auto it = my_map.begin(); it != my_map.end(); ++it) {
//	if (it->first == True)
//		my_map[it->first]++;
//	else if (it->first == False)
//		my_map[False]++;
//	else my_map[Unknown]++;
//}

//void resize(size_t new_size);
//void Tritset::resize(size_t new_size) {
//
//	size_t new_uints = new_size / 4 / sizeof(uint);
//	if (new_size > _capacity) {
//		_size = new_size;
//		_array.resize(new_uints + 1, 0);
//		_capacity = new_size + 1;
//	}
//	else if (new_size > _size && new_size < _capacity) {
//		_size = new_size;
//	}
//	else _size = new_size;
//
//}
